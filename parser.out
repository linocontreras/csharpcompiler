Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DIVIDE
    ELSE
    MINUS
    PLUS
    TIMES
    TYPE

Grammar

Rule 0     S' -> start
Rule 1     start -> statement_list
Rule 2     statement_list -> statement_list statement
Rule 3     statement_list -> empty
Rule 4     statement -> asignment
Rule 5     statement -> CONST asignment
Rule 6     statement -> block_statement
Rule 7     statement -> call SEMICOLON
Rule 8     asignment -> type IDENTIFIER ASSIGNMENT expression SEMICOLON
Rule 9     expression -> int_expression
Rule 10    expression -> double_expression
Rule 11    expression -> string_expression
Rule 12    expression -> bool_expression
Rule 13    expression -> call
Rule 14    block_statement -> if
Rule 15    block_statement -> while
Rule 16    if -> IF LPAREN bool_expression RPAREN block_or_statement
Rule 17    while -> WHILE LPAREN bool_expression RPAREN block_or_statement
Rule 18    block_or_statement -> statement
Rule 19    block_or_statement -> block
Rule 20    block -> LBRACKET statement_list RBRACKET
Rule 21    int_expression -> INTEGER_LITERAL
Rule 22    fqn -> IDENTIFIER
Rule 23    fqn -> fqn DOT IDENTIFIER
Rule 24    type_name -> type IDENTIFIER
Rule 25    arguments -> arguments COMMA type_name
Rule 26    arguments -> type_name
Rule 27    arguments -> empty
Rule 28    arguments_call -> arguments_call COMMA expression
Rule 29    arguments_call -> expression
Rule 30    arguments_call -> empty
Rule 31    call -> fqn LPAREN arguments_call RPAREN
Rule 32    double_expression -> DOUBLE_LITERAL
Rule 33    string_expression -> STRING_LITERAL
Rule 34    string_expression -> call
Rule 35    bool_expression -> TRUE
Rule 36    bool_expression -> FALSE
Rule 37    type -> INT
Rule 38    type -> DOUBLE
Rule 39    type -> STRING
Rule 40    type -> BOOL
Rule 41    empty -> <empty>

Terminals, with rules where they appear

ASSIGNMENT           : 8
BOOL                 : 40
COMMA                : 25 28
CONST                : 5
DIVIDE               : 
DOT                  : 23
DOUBLE               : 38
DOUBLE_LITERAL       : 32
ELSE                 : 
FALSE                : 36
IDENTIFIER           : 8 22 23 24
IF                   : 16
INT                  : 37
INTEGER_LITERAL      : 21
LBRACKET             : 20
LPAREN               : 16 17 31
MINUS                : 
PLUS                 : 
RBRACKET             : 20
RPAREN               : 16 17 31
SEMICOLON            : 7 8
STRING               : 39
STRING_LITERAL       : 33
TIMES                : 
TRUE                 : 35
TYPE                 : 
WHILE                : 17
error                : 

Nonterminals, with rules where they appear

arguments            : 25
arguments_call       : 28 31
asignment            : 4 5
block                : 19
block_or_statement   : 16 17
block_statement      : 6
bool_expression      : 12 16 17
call                 : 7 13 34
double_expression    : 10
empty                : 3 27 30
expression           : 8 28 29
fqn                  : 23 31
if                   : 14
int_expression       : 9
start                : 0
statement            : 2 18
statement_list       : 1 2 20
string_expression    : 11
type                 : 8 24
type_name            : 25 26
while                : 15

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . statement_list
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . empty
    (41) empty -> .

    CONST           reduce using rule 41 (empty -> .)
    INT             reduce using rule 41 (empty -> .)
    DOUBLE          reduce using rule 41 (empty -> .)
    STRING          reduce using rule 41 (empty -> .)
    BOOL            reduce using rule 41 (empty -> .)
    IF              reduce using rule 41 (empty -> .)
    WHILE           reduce using rule 41 (empty -> .)
    IDENTIFIER      reduce using rule 41 (empty -> .)
    $end            reduce using rule 41 (empty -> .)

    start                          shift and go to state 1
    statement_list                 shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> start .



state 2

    (1) start -> statement_list .
    (2) statement_list -> statement_list . statement
    (4) statement -> . asignment
    (5) statement -> . CONST asignment
    (6) statement -> . block_statement
    (7) statement -> . call SEMICOLON
    (8) asignment -> . type IDENTIFIER ASSIGNMENT expression SEMICOLON
    (14) block_statement -> . if
    (15) block_statement -> . while
    (31) call -> . fqn LPAREN arguments_call RPAREN
    (37) type -> . INT
    (38) type -> . DOUBLE
    (39) type -> . STRING
    (40) type -> . BOOL
    (16) if -> . IF LPAREN bool_expression RPAREN block_or_statement
    (17) while -> . WHILE LPAREN bool_expression RPAREN block_or_statement
    (22) fqn -> . IDENTIFIER
    (23) fqn -> . fqn DOT IDENTIFIER

    $end            reduce using rule 1 (start -> statement_list .)
    CONST           shift and go to state 6
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    BOOL            shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    IDENTIFIER      shift and go to state 10

    statement                      shift and go to state 4
    asignment                      shift and go to state 5
    block_statement                shift and go to state 7
    call                           shift and go to state 8
    type                           shift and go to state 9
    if                             shift and go to state 11
    while                          shift and go to state 12
    fqn                            shift and go to state 13

state 3

    (3) statement_list -> empty .

    CONST           reduce using rule 3 (statement_list -> empty .)
    INT             reduce using rule 3 (statement_list -> empty .)
    DOUBLE          reduce using rule 3 (statement_list -> empty .)
    STRING          reduce using rule 3 (statement_list -> empty .)
    BOOL            reduce using rule 3 (statement_list -> empty .)
    IF              reduce using rule 3 (statement_list -> empty .)
    WHILE           reduce using rule 3 (statement_list -> empty .)
    IDENTIFIER      reduce using rule 3 (statement_list -> empty .)
    $end            reduce using rule 3 (statement_list -> empty .)
    RBRACKET        reduce using rule 3 (statement_list -> empty .)


state 4

    (2) statement_list -> statement_list statement .

    CONST           reduce using rule 2 (statement_list -> statement_list statement .)
    INT             reduce using rule 2 (statement_list -> statement_list statement .)
    DOUBLE          reduce using rule 2 (statement_list -> statement_list statement .)
    STRING          reduce using rule 2 (statement_list -> statement_list statement .)
    BOOL            reduce using rule 2 (statement_list -> statement_list statement .)
    IF              reduce using rule 2 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 2 (statement_list -> statement_list statement .)
    IDENTIFIER      reduce using rule 2 (statement_list -> statement_list statement .)
    $end            reduce using rule 2 (statement_list -> statement_list statement .)
    RBRACKET        reduce using rule 2 (statement_list -> statement_list statement .)


state 5

    (4) statement -> asignment .

    CONST           reduce using rule 4 (statement -> asignment .)
    INT             reduce using rule 4 (statement -> asignment .)
    DOUBLE          reduce using rule 4 (statement -> asignment .)
    STRING          reduce using rule 4 (statement -> asignment .)
    BOOL            reduce using rule 4 (statement -> asignment .)
    IF              reduce using rule 4 (statement -> asignment .)
    WHILE           reduce using rule 4 (statement -> asignment .)
    IDENTIFIER      reduce using rule 4 (statement -> asignment .)
    $end            reduce using rule 4 (statement -> asignment .)
    RBRACKET        reduce using rule 4 (statement -> asignment .)


state 6

    (5) statement -> CONST . asignment
    (8) asignment -> . type IDENTIFIER ASSIGNMENT expression SEMICOLON
    (37) type -> . INT
    (38) type -> . DOUBLE
    (39) type -> . STRING
    (40) type -> . BOOL

    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    BOOL            shift and go to state 17

    asignment                      shift and go to state 20
    type                           shift and go to state 9

state 7

    (6) statement -> block_statement .

    CONST           reduce using rule 6 (statement -> block_statement .)
    INT             reduce using rule 6 (statement -> block_statement .)
    DOUBLE          reduce using rule 6 (statement -> block_statement .)
    STRING          reduce using rule 6 (statement -> block_statement .)
    BOOL            reduce using rule 6 (statement -> block_statement .)
    IF              reduce using rule 6 (statement -> block_statement .)
    WHILE           reduce using rule 6 (statement -> block_statement .)
    IDENTIFIER      reduce using rule 6 (statement -> block_statement .)
    $end            reduce using rule 6 (statement -> block_statement .)
    RBRACKET        reduce using rule 6 (statement -> block_statement .)


state 8

    (7) statement -> call . SEMICOLON

    SEMICOLON       shift and go to state 21


state 9

    (8) asignment -> type . IDENTIFIER ASSIGNMENT expression SEMICOLON

    IDENTIFIER      shift and go to state 22


state 10

    (22) fqn -> IDENTIFIER .

    LPAREN          reduce using rule 22 (fqn -> IDENTIFIER .)
    DOT             reduce using rule 22 (fqn -> IDENTIFIER .)


state 11

    (14) block_statement -> if .

    CONST           reduce using rule 14 (block_statement -> if .)
    INT             reduce using rule 14 (block_statement -> if .)
    DOUBLE          reduce using rule 14 (block_statement -> if .)
    STRING          reduce using rule 14 (block_statement -> if .)
    BOOL            reduce using rule 14 (block_statement -> if .)
    IF              reduce using rule 14 (block_statement -> if .)
    WHILE           reduce using rule 14 (block_statement -> if .)
    IDENTIFIER      reduce using rule 14 (block_statement -> if .)
    $end            reduce using rule 14 (block_statement -> if .)
    RBRACKET        reduce using rule 14 (block_statement -> if .)


state 12

    (15) block_statement -> while .

    CONST           reduce using rule 15 (block_statement -> while .)
    INT             reduce using rule 15 (block_statement -> while .)
    DOUBLE          reduce using rule 15 (block_statement -> while .)
    STRING          reduce using rule 15 (block_statement -> while .)
    BOOL            reduce using rule 15 (block_statement -> while .)
    IF              reduce using rule 15 (block_statement -> while .)
    WHILE           reduce using rule 15 (block_statement -> while .)
    IDENTIFIER      reduce using rule 15 (block_statement -> while .)
    $end            reduce using rule 15 (block_statement -> while .)
    RBRACKET        reduce using rule 15 (block_statement -> while .)


state 13

    (31) call -> fqn . LPAREN arguments_call RPAREN
    (23) fqn -> fqn . DOT IDENTIFIER

    LPAREN          shift and go to state 23
    DOT             shift and go to state 24


state 14

    (37) type -> INT .

    IDENTIFIER      reduce using rule 37 (type -> INT .)


state 15

    (38) type -> DOUBLE .

    IDENTIFIER      reduce using rule 38 (type -> DOUBLE .)


state 16

    (39) type -> STRING .

    IDENTIFIER      reduce using rule 39 (type -> STRING .)


state 17

    (40) type -> BOOL .

    IDENTIFIER      reduce using rule 40 (type -> BOOL .)


state 18

    (16) if -> IF . LPAREN bool_expression RPAREN block_or_statement

    LPAREN          shift and go to state 25


state 19

    (17) while -> WHILE . LPAREN bool_expression RPAREN block_or_statement

    LPAREN          shift and go to state 26


state 20

    (5) statement -> CONST asignment .

    CONST           reduce using rule 5 (statement -> CONST asignment .)
    INT             reduce using rule 5 (statement -> CONST asignment .)
    DOUBLE          reduce using rule 5 (statement -> CONST asignment .)
    STRING          reduce using rule 5 (statement -> CONST asignment .)
    BOOL            reduce using rule 5 (statement -> CONST asignment .)
    IF              reduce using rule 5 (statement -> CONST asignment .)
    WHILE           reduce using rule 5 (statement -> CONST asignment .)
    IDENTIFIER      reduce using rule 5 (statement -> CONST asignment .)
    $end            reduce using rule 5 (statement -> CONST asignment .)
    RBRACKET        reduce using rule 5 (statement -> CONST asignment .)


state 21

    (7) statement -> call SEMICOLON .

    CONST           reduce using rule 7 (statement -> call SEMICOLON .)
    INT             reduce using rule 7 (statement -> call SEMICOLON .)
    DOUBLE          reduce using rule 7 (statement -> call SEMICOLON .)
    STRING          reduce using rule 7 (statement -> call SEMICOLON .)
    BOOL            reduce using rule 7 (statement -> call SEMICOLON .)
    IF              reduce using rule 7 (statement -> call SEMICOLON .)
    WHILE           reduce using rule 7 (statement -> call SEMICOLON .)
    IDENTIFIER      reduce using rule 7 (statement -> call SEMICOLON .)
    $end            reduce using rule 7 (statement -> call SEMICOLON .)
    RBRACKET        reduce using rule 7 (statement -> call SEMICOLON .)


state 22

    (8) asignment -> type IDENTIFIER . ASSIGNMENT expression SEMICOLON

    ASSIGNMENT      shift and go to state 27


state 23

    (31) call -> fqn LPAREN . arguments_call RPAREN
    (28) arguments_call -> . arguments_call COMMA expression
    (29) arguments_call -> . expression
    (30) arguments_call -> . empty
    (9) expression -> . int_expression
    (10) expression -> . double_expression
    (11) expression -> . string_expression
    (12) expression -> . bool_expression
    (13) expression -> . call
    (41) empty -> .
    (21) int_expression -> . INTEGER_LITERAL
    (32) double_expression -> . DOUBLE_LITERAL
    (33) string_expression -> . STRING_LITERAL
    (34) string_expression -> . call
    (35) bool_expression -> . TRUE
    (36) bool_expression -> . FALSE
    (31) call -> . fqn LPAREN arguments_call RPAREN
    (22) fqn -> . IDENTIFIER
    (23) fqn -> . fqn DOT IDENTIFIER

    RPAREN          reduce using rule 41 (empty -> .)
    COMMA           reduce using rule 41 (empty -> .)
    INTEGER_LITERAL shift and go to state 36
    DOUBLE_LITERAL  shift and go to state 37
    STRING_LITERAL  shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    IDENTIFIER      shift and go to state 10

    fqn                            shift and go to state 13
    arguments_call                 shift and go to state 28
    expression                     shift and go to state 29
    empty                          shift and go to state 30
    int_expression                 shift and go to state 31
    double_expression              shift and go to state 32
    string_expression              shift and go to state 33
    bool_expression                shift and go to state 34
    call                           shift and go to state 35

state 24

    (23) fqn -> fqn DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 41


state 25

    (16) if -> IF LPAREN . bool_expression RPAREN block_or_statement
    (35) bool_expression -> . TRUE
    (36) bool_expression -> . FALSE

    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    bool_expression                shift and go to state 42

state 26

    (17) while -> WHILE LPAREN . bool_expression RPAREN block_or_statement
    (35) bool_expression -> . TRUE
    (36) bool_expression -> . FALSE

    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    bool_expression                shift and go to state 43

state 27

    (8) asignment -> type IDENTIFIER ASSIGNMENT . expression SEMICOLON
    (9) expression -> . int_expression
    (10) expression -> . double_expression
    (11) expression -> . string_expression
    (12) expression -> . bool_expression
    (13) expression -> . call
    (21) int_expression -> . INTEGER_LITERAL
    (32) double_expression -> . DOUBLE_LITERAL
    (33) string_expression -> . STRING_LITERAL
    (34) string_expression -> . call
    (35) bool_expression -> . TRUE
    (36) bool_expression -> . FALSE
    (31) call -> . fqn LPAREN arguments_call RPAREN
    (22) fqn -> . IDENTIFIER
    (23) fqn -> . fqn DOT IDENTIFIER

    INTEGER_LITERAL shift and go to state 36
    DOUBLE_LITERAL  shift and go to state 37
    STRING_LITERAL  shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    IDENTIFIER      shift and go to state 10

    expression                     shift and go to state 44
    int_expression                 shift and go to state 31
    double_expression              shift and go to state 32
    string_expression              shift and go to state 33
    bool_expression                shift and go to state 34
    call                           shift and go to state 35
    fqn                            shift and go to state 13

state 28

    (31) call -> fqn LPAREN arguments_call . RPAREN
    (28) arguments_call -> arguments_call . COMMA expression

    RPAREN          shift and go to state 45
    COMMA           shift and go to state 46


state 29

    (29) arguments_call -> expression .

    RPAREN          reduce using rule 29 (arguments_call -> expression .)
    COMMA           reduce using rule 29 (arguments_call -> expression .)


state 30

    (30) arguments_call -> empty .

    RPAREN          reduce using rule 30 (arguments_call -> empty .)
    COMMA           reduce using rule 30 (arguments_call -> empty .)


state 31

    (9) expression -> int_expression .

    RPAREN          reduce using rule 9 (expression -> int_expression .)
    COMMA           reduce using rule 9 (expression -> int_expression .)
    SEMICOLON       reduce using rule 9 (expression -> int_expression .)


state 32

    (10) expression -> double_expression .

    RPAREN          reduce using rule 10 (expression -> double_expression .)
    COMMA           reduce using rule 10 (expression -> double_expression .)
    SEMICOLON       reduce using rule 10 (expression -> double_expression .)


state 33

    (11) expression -> string_expression .

    RPAREN          reduce using rule 11 (expression -> string_expression .)
    COMMA           reduce using rule 11 (expression -> string_expression .)
    SEMICOLON       reduce using rule 11 (expression -> string_expression .)


state 34

    (12) expression -> bool_expression .

    RPAREN          reduce using rule 12 (expression -> bool_expression .)
    COMMA           reduce using rule 12 (expression -> bool_expression .)
    SEMICOLON       reduce using rule 12 (expression -> bool_expression .)


state 35

    (13) expression -> call .
    (34) string_expression -> call .

  ! reduce/reduce conflict for RPAREN resolved using rule 13 (expression -> call .)
  ! reduce/reduce conflict for COMMA resolved using rule 13 (expression -> call .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 13 (expression -> call .)
    RPAREN          reduce using rule 13 (expression -> call .)
    COMMA           reduce using rule 13 (expression -> call .)
    SEMICOLON       reduce using rule 13 (expression -> call .)

  ! RPAREN          [ reduce using rule 34 (string_expression -> call .) ]
  ! COMMA           [ reduce using rule 34 (string_expression -> call .) ]
  ! SEMICOLON       [ reduce using rule 34 (string_expression -> call .) ]


state 36

    (21) int_expression -> INTEGER_LITERAL .

    RPAREN          reduce using rule 21 (int_expression -> INTEGER_LITERAL .)
    COMMA           reduce using rule 21 (int_expression -> INTEGER_LITERAL .)
    SEMICOLON       reduce using rule 21 (int_expression -> INTEGER_LITERAL .)


state 37

    (32) double_expression -> DOUBLE_LITERAL .

    RPAREN          reduce using rule 32 (double_expression -> DOUBLE_LITERAL .)
    COMMA           reduce using rule 32 (double_expression -> DOUBLE_LITERAL .)
    SEMICOLON       reduce using rule 32 (double_expression -> DOUBLE_LITERAL .)


state 38

    (33) string_expression -> STRING_LITERAL .

    RPAREN          reduce using rule 33 (string_expression -> STRING_LITERAL .)
    COMMA           reduce using rule 33 (string_expression -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 33 (string_expression -> STRING_LITERAL .)


state 39

    (35) bool_expression -> TRUE .

    RPAREN          reduce using rule 35 (bool_expression -> TRUE .)
    COMMA           reduce using rule 35 (bool_expression -> TRUE .)
    SEMICOLON       reduce using rule 35 (bool_expression -> TRUE .)


state 40

    (36) bool_expression -> FALSE .

    RPAREN          reduce using rule 36 (bool_expression -> FALSE .)
    COMMA           reduce using rule 36 (bool_expression -> FALSE .)
    SEMICOLON       reduce using rule 36 (bool_expression -> FALSE .)


state 41

    (23) fqn -> fqn DOT IDENTIFIER .

    LPAREN          reduce using rule 23 (fqn -> fqn DOT IDENTIFIER .)
    DOT             reduce using rule 23 (fqn -> fqn DOT IDENTIFIER .)


state 42

    (16) if -> IF LPAREN bool_expression . RPAREN block_or_statement

    RPAREN          shift and go to state 47


state 43

    (17) while -> WHILE LPAREN bool_expression . RPAREN block_or_statement

    RPAREN          shift and go to state 48


state 44

    (8) asignment -> type IDENTIFIER ASSIGNMENT expression . SEMICOLON

    SEMICOLON       shift and go to state 49


state 45

    (31) call -> fqn LPAREN arguments_call RPAREN .

    SEMICOLON       reduce using rule 31 (call -> fqn LPAREN arguments_call RPAREN .)
    RPAREN          reduce using rule 31 (call -> fqn LPAREN arguments_call RPAREN .)
    COMMA           reduce using rule 31 (call -> fqn LPAREN arguments_call RPAREN .)


state 46

    (28) arguments_call -> arguments_call COMMA . expression
    (9) expression -> . int_expression
    (10) expression -> . double_expression
    (11) expression -> . string_expression
    (12) expression -> . bool_expression
    (13) expression -> . call
    (21) int_expression -> . INTEGER_LITERAL
    (32) double_expression -> . DOUBLE_LITERAL
    (33) string_expression -> . STRING_LITERAL
    (34) string_expression -> . call
    (35) bool_expression -> . TRUE
    (36) bool_expression -> . FALSE
    (31) call -> . fqn LPAREN arguments_call RPAREN
    (22) fqn -> . IDENTIFIER
    (23) fqn -> . fqn DOT IDENTIFIER

    INTEGER_LITERAL shift and go to state 36
    DOUBLE_LITERAL  shift and go to state 37
    STRING_LITERAL  shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    IDENTIFIER      shift and go to state 10

    expression                     shift and go to state 50
    int_expression                 shift and go to state 31
    double_expression              shift and go to state 32
    string_expression              shift and go to state 33
    bool_expression                shift and go to state 34
    call                           shift and go to state 35
    fqn                            shift and go to state 13

state 47

    (16) if -> IF LPAREN bool_expression RPAREN . block_or_statement
    (18) block_or_statement -> . statement
    (19) block_or_statement -> . block
    (4) statement -> . asignment
    (5) statement -> . CONST asignment
    (6) statement -> . block_statement
    (7) statement -> . call SEMICOLON
    (20) block -> . LBRACKET statement_list RBRACKET
    (8) asignment -> . type IDENTIFIER ASSIGNMENT expression SEMICOLON
    (14) block_statement -> . if
    (15) block_statement -> . while
    (31) call -> . fqn LPAREN arguments_call RPAREN
    (37) type -> . INT
    (38) type -> . DOUBLE
    (39) type -> . STRING
    (40) type -> . BOOL
    (16) if -> . IF LPAREN bool_expression RPAREN block_or_statement
    (17) while -> . WHILE LPAREN bool_expression RPAREN block_or_statement
    (22) fqn -> . IDENTIFIER
    (23) fqn -> . fqn DOT IDENTIFIER

    CONST           shift and go to state 6
    LBRACKET        shift and go to state 54
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    BOOL            shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    IDENTIFIER      shift and go to state 10

    block_or_statement             shift and go to state 51
    statement                      shift and go to state 52
    block                          shift and go to state 53
    asignment                      shift and go to state 5
    block_statement                shift and go to state 7
    call                           shift and go to state 8
    type                           shift and go to state 9
    if                             shift and go to state 11
    while                          shift and go to state 12
    fqn                            shift and go to state 13

state 48

    (17) while -> WHILE LPAREN bool_expression RPAREN . block_or_statement
    (18) block_or_statement -> . statement
    (19) block_or_statement -> . block
    (4) statement -> . asignment
    (5) statement -> . CONST asignment
    (6) statement -> . block_statement
    (7) statement -> . call SEMICOLON
    (20) block -> . LBRACKET statement_list RBRACKET
    (8) asignment -> . type IDENTIFIER ASSIGNMENT expression SEMICOLON
    (14) block_statement -> . if
    (15) block_statement -> . while
    (31) call -> . fqn LPAREN arguments_call RPAREN
    (37) type -> . INT
    (38) type -> . DOUBLE
    (39) type -> . STRING
    (40) type -> . BOOL
    (16) if -> . IF LPAREN bool_expression RPAREN block_or_statement
    (17) while -> . WHILE LPAREN bool_expression RPAREN block_or_statement
    (22) fqn -> . IDENTIFIER
    (23) fqn -> . fqn DOT IDENTIFIER

    CONST           shift and go to state 6
    LBRACKET        shift and go to state 54
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    BOOL            shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    IDENTIFIER      shift and go to state 10

    block_or_statement             shift and go to state 55
    statement                      shift and go to state 52
    block                          shift and go to state 53
    asignment                      shift and go to state 5
    block_statement                shift and go to state 7
    call                           shift and go to state 8
    type                           shift and go to state 9
    if                             shift and go to state 11
    while                          shift and go to state 12
    fqn                            shift and go to state 13

state 49

    (8) asignment -> type IDENTIFIER ASSIGNMENT expression SEMICOLON .

    CONST           reduce using rule 8 (asignment -> type IDENTIFIER ASSIGNMENT expression SEMICOLON .)
    INT             reduce using rule 8 (asignment -> type IDENTIFIER ASSIGNMENT expression SEMICOLON .)
    DOUBLE          reduce using rule 8 (asignment -> type IDENTIFIER ASSIGNMENT expression SEMICOLON .)
    STRING          reduce using rule 8 (asignment -> type IDENTIFIER ASSIGNMENT expression SEMICOLON .)
    BOOL            reduce using rule 8 (asignment -> type IDENTIFIER ASSIGNMENT expression SEMICOLON .)
    IF              reduce using rule 8 (asignment -> type IDENTIFIER ASSIGNMENT expression SEMICOLON .)
    WHILE           reduce using rule 8 (asignment -> type IDENTIFIER ASSIGNMENT expression SEMICOLON .)
    IDENTIFIER      reduce using rule 8 (asignment -> type IDENTIFIER ASSIGNMENT expression SEMICOLON .)
    $end            reduce using rule 8 (asignment -> type IDENTIFIER ASSIGNMENT expression SEMICOLON .)
    RBRACKET        reduce using rule 8 (asignment -> type IDENTIFIER ASSIGNMENT expression SEMICOLON .)


state 50

    (28) arguments_call -> arguments_call COMMA expression .

    RPAREN          reduce using rule 28 (arguments_call -> arguments_call COMMA expression .)
    COMMA           reduce using rule 28 (arguments_call -> arguments_call COMMA expression .)


state 51

    (16) if -> IF LPAREN bool_expression RPAREN block_or_statement .

    CONST           reduce using rule 16 (if -> IF LPAREN bool_expression RPAREN block_or_statement .)
    INT             reduce using rule 16 (if -> IF LPAREN bool_expression RPAREN block_or_statement .)
    DOUBLE          reduce using rule 16 (if -> IF LPAREN bool_expression RPAREN block_or_statement .)
    STRING          reduce using rule 16 (if -> IF LPAREN bool_expression RPAREN block_or_statement .)
    BOOL            reduce using rule 16 (if -> IF LPAREN bool_expression RPAREN block_or_statement .)
    IF              reduce using rule 16 (if -> IF LPAREN bool_expression RPAREN block_or_statement .)
    WHILE           reduce using rule 16 (if -> IF LPAREN bool_expression RPAREN block_or_statement .)
    IDENTIFIER      reduce using rule 16 (if -> IF LPAREN bool_expression RPAREN block_or_statement .)
    $end            reduce using rule 16 (if -> IF LPAREN bool_expression RPAREN block_or_statement .)
    RBRACKET        reduce using rule 16 (if -> IF LPAREN bool_expression RPAREN block_or_statement .)


state 52

    (18) block_or_statement -> statement .

    CONST           reduce using rule 18 (block_or_statement -> statement .)
    INT             reduce using rule 18 (block_or_statement -> statement .)
    DOUBLE          reduce using rule 18 (block_or_statement -> statement .)
    STRING          reduce using rule 18 (block_or_statement -> statement .)
    BOOL            reduce using rule 18 (block_or_statement -> statement .)
    IF              reduce using rule 18 (block_or_statement -> statement .)
    WHILE           reduce using rule 18 (block_or_statement -> statement .)
    IDENTIFIER      reduce using rule 18 (block_or_statement -> statement .)
    $end            reduce using rule 18 (block_or_statement -> statement .)
    RBRACKET        reduce using rule 18 (block_or_statement -> statement .)


state 53

    (19) block_or_statement -> block .

    CONST           reduce using rule 19 (block_or_statement -> block .)
    INT             reduce using rule 19 (block_or_statement -> block .)
    DOUBLE          reduce using rule 19 (block_or_statement -> block .)
    STRING          reduce using rule 19 (block_or_statement -> block .)
    BOOL            reduce using rule 19 (block_or_statement -> block .)
    IF              reduce using rule 19 (block_or_statement -> block .)
    WHILE           reduce using rule 19 (block_or_statement -> block .)
    IDENTIFIER      reduce using rule 19 (block_or_statement -> block .)
    $end            reduce using rule 19 (block_or_statement -> block .)
    RBRACKET        reduce using rule 19 (block_or_statement -> block .)


state 54

    (20) block -> LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . empty
    (41) empty -> .

    RBRACKET        reduce using rule 41 (empty -> .)
    CONST           reduce using rule 41 (empty -> .)
    INT             reduce using rule 41 (empty -> .)
    DOUBLE          reduce using rule 41 (empty -> .)
    STRING          reduce using rule 41 (empty -> .)
    BOOL            reduce using rule 41 (empty -> .)
    IF              reduce using rule 41 (empty -> .)
    WHILE           reduce using rule 41 (empty -> .)
    IDENTIFIER      reduce using rule 41 (empty -> .)

    statement_list                 shift and go to state 56
    empty                          shift and go to state 3

state 55

    (17) while -> WHILE LPAREN bool_expression RPAREN block_or_statement .

    CONST           reduce using rule 17 (while -> WHILE LPAREN bool_expression RPAREN block_or_statement .)
    INT             reduce using rule 17 (while -> WHILE LPAREN bool_expression RPAREN block_or_statement .)
    DOUBLE          reduce using rule 17 (while -> WHILE LPAREN bool_expression RPAREN block_or_statement .)
    STRING          reduce using rule 17 (while -> WHILE LPAREN bool_expression RPAREN block_or_statement .)
    BOOL            reduce using rule 17 (while -> WHILE LPAREN bool_expression RPAREN block_or_statement .)
    IF              reduce using rule 17 (while -> WHILE LPAREN bool_expression RPAREN block_or_statement .)
    WHILE           reduce using rule 17 (while -> WHILE LPAREN bool_expression RPAREN block_or_statement .)
    IDENTIFIER      reduce using rule 17 (while -> WHILE LPAREN bool_expression RPAREN block_or_statement .)
    $end            reduce using rule 17 (while -> WHILE LPAREN bool_expression RPAREN block_or_statement .)
    RBRACKET        reduce using rule 17 (while -> WHILE LPAREN bool_expression RPAREN block_or_statement .)


state 56

    (20) block -> LBRACKET statement_list . RBRACKET
    (2) statement_list -> statement_list . statement
    (4) statement -> . asignment
    (5) statement -> . CONST asignment
    (6) statement -> . block_statement
    (7) statement -> . call SEMICOLON
    (8) asignment -> . type IDENTIFIER ASSIGNMENT expression SEMICOLON
    (14) block_statement -> . if
    (15) block_statement -> . while
    (31) call -> . fqn LPAREN arguments_call RPAREN
    (37) type -> . INT
    (38) type -> . DOUBLE
    (39) type -> . STRING
    (40) type -> . BOOL
    (16) if -> . IF LPAREN bool_expression RPAREN block_or_statement
    (17) while -> . WHILE LPAREN bool_expression RPAREN block_or_statement
    (22) fqn -> . IDENTIFIER
    (23) fqn -> . fqn DOT IDENTIFIER

    RBRACKET        shift and go to state 57
    CONST           shift and go to state 6
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    STRING          shift and go to state 16
    BOOL            shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    IDENTIFIER      shift and go to state 10

    statement                      shift and go to state 4
    asignment                      shift and go to state 5
    block_statement                shift and go to state 7
    call                           shift and go to state 8
    type                           shift and go to state 9
    if                             shift and go to state 11
    while                          shift and go to state 12
    fqn                            shift and go to state 13

state 57

    (20) block -> LBRACKET statement_list RBRACKET .

    CONST           reduce using rule 20 (block -> LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 20 (block -> LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 20 (block -> LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 20 (block -> LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 20 (block -> LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 20 (block -> LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 20 (block -> LBRACKET statement_list RBRACKET .)
    IDENTIFIER      reduce using rule 20 (block -> LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 20 (block -> LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 20 (block -> LBRACKET statement_list RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 35 resolved using rule (expression -> call)
WARNING: rejected rule (string_expression -> call) in state 35
WARNING: Rule (string_expression -> call) is never reduced
